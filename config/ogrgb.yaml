substitutions:
  device_name: ogrgb

esphome:
  name: ${device_name}
  platformio_options:
    board_build.f_cpu: 80000000L
    build_type: release
    build_flags:
      - -Os
      - -DCONFIG_ESP32_WIFI_DYNAMIC_TX_BUF
  on_boot:
    priority: 800
    then:
      - logger.log: "Boot successful."
      - deep_sleep.prevent: deep_sleep_1
      - script.execute: arm_sleep_timeout

esp32:
  board: esp32-s3-devkitc-1
  variant: ESP32S3
  framework:
    type: esp-idf

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
  power_save_mode: HIGH
  output_power: 17

logger:
  level: WARN
  baud_rate: 0

ota:
  platform: esphome
  password: !secret ota_password

mqtt:
  id: mqtt_client
  broker: !secret mqtt_broker
  port: !secret mqtt_port
  client_id: "${device_name}"
  discovery: false
  log_topic: null

  birth_message:
    topic: "${device_name}/status"
    payload: "online"
    qos: 1
    retain: true

  will_message:
    topic: "${device_name}/status"
    payload: "offline"
    qos: 1
    retain: true

  on_connect:
    then:
      - lambda: |
          id(seen_mask) = 0;
          id(ready) = false;
          id(sleep_timeout_expired) = false;
      - script.execute: arm_sleep_timeout
      - delay: 5s
      - lambda: |
          if (!id(ready)) id(ready) = true;
      - script.execute: recompute_and_publish
      - script.execute: maybe_finish_and_sleep

  on_message:
    - topic: "${device_name}/online_lock"
      qos: 1
      then:
        - lambda: |
            id(online_lock) = (x == "true");
            id(seen_mask) |= 0x01;
        - script.execute: online_lock_timeout_arm
        - script.execute: recompute_and_publish
        - script.execute: maybe_finish_and_sleep

    - topic: "My OpenGarage/OUT/STATUS"
      qos: 1
      then:
        - lambda: |
            id(og_online) = (x == "online");
            id(seen_mask) |= 0x02;
        - script.execute: recompute_and_publish
        - script.execute: maybe_finish_and_sleep

    - topic: "${device_name}/light_control"
      qos: 1
      then:
        - lambda: |
            id(door_open) = (x == "on");
            id(seen_mask) |= 0x04;
        - script.execute: recompute_and_publish
        - script.execute: maybe_finish_and_sleep

globals:
  - id: door_open
    type: bool
    initial_value: "false"
  - id: og_online
    type: bool
    initial_value: "true"
  - id: online_lock
    type: bool
    initial_value: "false"

  # Bitmask: bit0 = online_lock, bit1 = og_online, bit2 = door_open
  - id: seen_mask
    type: uint8_t
    initial_value: "0"
  - id: ready
    type: bool
    initial_value: "false"

  - id: sleep_timeout_expired
    type: bool
    initial_value: "false"

  - id: last_color
    type: uint8_t
    initial_value: "255"
    restore_value: true

  - id: last_light_on
    type: bool
    initial_value: "false"
    restore_value: true

  - id: boot_count
    type: uint32_t
    initial_value: "0"
    restore_value: true

deep_sleep:
  id: deep_sleep_1
  run_duration: 3s
  sleep_duration: 30s

light:
  - platform: esp32_rmt_led_strip
    chipset: WS2812
    pin: GPIO48
    num_leds: 1
    rgb_order: GRB
    name: "${device_name} Light"
    id: ogrgb_light
    default_transition_length: 0s
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - mqtt.publish:
          topic: "${device_name}/light/light_status"
          payload: "on"
          qos: 1
          retain: true
      - lambda: 'ESP_LOGD("Light", "Light turned on"); id(last_light_on) = true;'
    on_turn_off:
      - mqtt.publish:
          topic: "${device_name}/light/light_status"
          payload: "off"
          qos: 1
          retain: true
      - lambda: 'ESP_LOGD("Light", "Light turned off"); id(last_light_on) = false;'
    effects:
      - addressable_rainbow:
          name: "Rainbow"
          speed: 10

script:
  - id: arm_sleep_timeout
    mode: restart
    then:
      - delay: 20s
      - lambda: |-
          if (!id(sleep_timeout_expired)) {
            id(sleep_timeout_expired) = true;
            ESP_LOGI("sleep", "Sleep timeout expired after 20 seconds.");
          }
      - script.execute: maybe_finish_and_sleep

  - id: recompute_and_publish
    mode: restart
    then:
      - lambda: |-
          uint8_t color = 0;
          bool light_on = false;

          if (id(door_open) && id(og_online)) {
            color = 0; light_on = true;
          } else if (id(door_open) && !id(og_online)) {
            color = 1; light_on = true;
          } else if (!id(door_open) && id(og_online)) {
            color = 2; light_on = false;
          } else {
            color = 3; light_on = true;
          }

          id(boot_count)++;

          if (color != id(last_color)) {
            id(last_color) = color;

            if (color == 0) {
              id(ogrgb_light).turn_on().set_brightness(0.40).set_rgb(0.0, 1.0, 0.0).perform();
            } else if (color == 1) {
              id(ogrgb_light).turn_on().set_brightness(0.40).set_rgb(0.0, 0.0, 1.0).perform();
            } else if (color == 2) {
              id(ogrgb_light).turn_off().perform();
            } else {
              id(ogrgb_light).turn_on().set_brightness(0.40).set_rgb(1.0, 0.0, 0.0).perform();
            }

            const char *cname = (color == 0) ? "green" : (color == 1) ? "blue" : (color == 2) ? "none" : "red";
            id(mqtt_client)->publish(
              (std::string)App.get_name() + "/light/light_color",
              cname,
              strlen(cname),
              1,
              true
            );
          }

          const char *cname2 =
            (id(last_color) == 0) ? "green" :
            (id(last_color) == 1) ? "blue" :
            (id(last_color) == 2) ? "none" : "red";
          char buf[160];
          snprintf(buf, sizeof(buf),
            "{\"door_open\":%s,\"og_online\":%s,\"color\":\"%s\",\"boots\":%u}",
            id(door_open) ? "true" : "false",
            id(og_online) ? "true" : "false",
            cname2,
            (unsigned)id(boot_count)
          );
          id(mqtt_client)->publish(
            (std::string)App.get_name() + "/state",
            buf,
            strlen(buf),
            1,
            true
          );

  - id: maybe_finish_and_sleep
    mode: restart
    then:
      - lambda: 'if (!id(ready)) return;'
      - if:
          condition:
            lambda: 'return id(sleep_timeout_expired);'
          then:
            - if:
                condition:
                  lambda: 'return id(online_lock);'
                then:
                  - lambda: |-
                      uint8_t missing = (~id(seen_mask)) & 0x07;
                      std::string missing_list;
                      if (missing & 0x01) missing_list += (missing_list.empty() ? "" : ", ") + std::string("online_lock");
                      if (missing & 0x02) missing_list += (missing_list.empty() ? "" : ", ") + std::string("garage_status");
                      if (missing & 0x04) missing_list += (missing_list.empty() ? "" : ", ") + std::string("light_control");
                      if (missing_list.empty()) missing_list = "none";
                      ESP_LOGI("sleep", "Sleep timeout expired but online lock active; remaining awake. Missing topics: %s", missing_list.c_str());
                else:
                  - lambda: |-
                      uint8_t missing = (~id(seen_mask)) & 0x07;
                      std::string missing_list;
                      if (missing & 0x01) missing_list += (missing_list.empty() ? "" : ", ") + std::string("online_lock");
                      if (missing & 0x02) missing_list += (missing_list.empty() ? "" : ", ") + std::string("garage_status");
                      if (missing & 0x04) missing_list += (missing_list.empty() ? "" : ", ") + std::string("light_control");
                      if (missing == 0) {
                        ESP_LOGI("sleep", "Sleep timeout expired; proceeding to deep sleep with all retained topics present.");
                      } else {
                        if (missing_list.empty()) missing_list = "unknown";
                        ESP_LOGW("sleep", "Sleep timeout expired; forcing deep sleep despite missing topics: %s", missing_list.c_str());
                      }
                  - deep_sleep.allow: deep_sleep_1
          else:
            - if:
                condition:
                  lambda: 'return id(seen_mask) == 0x07;'
                then:
                  - if:
                      condition:
                        lambda: 'return !id(online_lock);'
                      then:
                        - lambda: 'ESP_LOGI("sleep", "All retained topics received; entering deep sleep.");'
                        - deep_sleep.allow: deep_sleep_1
                      else:
                        - logger.log: "Online lock active, remaining awake."
                else:
                  - lambda: |-
                      uint8_t missing = (~id(seen_mask)) & 0x07;
                      std::string missing_list;
                      if (missing & 0x01) missing_list += (missing_list.empty() ? "" : ", ") + std::string("online_lock");
                      if (missing & 0x02) missing_list += (missing_list.empty() ? "" : ", ") + std::string("garage_status");
                      if (missing & 0x04) missing_list += (missing_list.empty() ? "" : ", ") + std::string("light_control");
                      if (missing_list.empty()) missing_list = "unknown";
                      ESP_LOGI("sleep", "Waiting for retained topics before sleeping; still missing: %s", missing_list.c_str());

  - id: online_lock_timeout_arm
    mode: restart
    then:
      - if:
          condition:
            lambda: 'return id(online_lock);'
          then:
            - delay: 3min
            - if:
                condition:
                  lambda: 'return id(online_lock);'
                then:
                  - lambda: 'id(online_lock) = false;'
                  - script.execute: maybe_finish_and_sleep

safe_mode:
  on_safe_mode:
    then:
      - logger.log: "Safe mode triggered!"
      - deep_sleep.prevent: deep_sleep_1
