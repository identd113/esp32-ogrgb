esphome:
  name: ogrgb
  name_add_mac_suffix: false
  platformio_options:
    board_build.f_cpu: 80000000L
    build_type: release
    build_flags:
      - "-DCONFIG_ESP32_WIFI_TASK_STACK_SIZE=2048"
      - "-DOTA_LOGGING_DISABLED"
      - "-Os"
      - "-DCONFIG_ESP32_WIFI_DYNAMIC_TX_BUF"

  on_boot:
    priority: 800
    then:
      - logger.log: "Boot successful."
      - deep_sleep.prevent: deep_sleep_1
      - lambda: 'id(mqtt_seen_recently) = false;'
      - script.execute: update_light

esp32:
  board: esp32-s3-devkitc-1
  variant: ESP32S3
  framework:
    type: esp-idf

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
  power_save_mode: HIGH
  reboot_timeout: 0s

  on_disconnect:
    then:
      - logger.log: "Wi-Fi disconnected → scheduling sleep & retry"
      - deep_sleep.allow: deep_sleep_1

  on_connect:
    then:
      - logger.log: "Wi-Fi connected → normal operation resumed"
      - deep_sleep.prevent: deep_sleep_1
      - lambda: 'id(mqtt_seen_recently) = false;'

logger:
  level: INFO

ota:
  - platform: esphome
    password: !secret ota_password

mqtt:
  broker: !secret mqtt_broker
  port: !secret mqtt_port
  client_id: ogrgb
  discovery: false

  on_connect:
    then:
      - mqtt.publish:
          topic: ogrgb/status
          payload: "online"
          qos: 1
          retain: true
      # NEW: publish online_lock state after connect (retained), with a short delay
      - delay: 750ms
      - mqtt.publish:
          topic: ogrgb/globals/online_lock
          payload: !lambda |-
            return id(online_lock) ? "true" : "false";
          qos: 1
          retain: true

  on_message:
    - topic: "ogrgb/online_lock"
      qos: 1
      then:
        - lambda: |-
            id(online_lock) = (x == "true");
            id(mqtt_seen_recently) = true;
            ESP_LOGI("MQTT", "online_lock=%s", x.c_str());
        - script.execute: update_light

    - topic: "My OpenGarage/OUT/STATUS"
      qos: 1
      then:
        - lambda: |-
            id(og_online) = (x == "online");
            id(mqtt_seen_recently) = true;
            ESP_LOGI("MQTT", "og_online=%s", x.c_str());
        - script.execute: update_light

    - topic: "ogrgb/light_control"
      qos: 1
      then:
        - lambda: |-
            id(door_open) = (x == "on");
            id(mqtt_seen_recently) = true;
            ESP_LOGI("MQTT", "door_open=%s", x.c_str());
        - script.execute: update_light

globals:
  - id: door_open
    type: bool
    initial_value: "false"
  - id: og_online
    type: bool
    initial_value: "true"
  - id: online_lock
    type: bool
    initial_value: "false"
  - id: mqtt_seen_recently
    type: bool
    initial_value: "false"
  - id: last_light_on
    type: bool
    initial_value: "false"
    restore_value: true

deep_sleep:
  id: deep_sleep_1
  run_duration: 1s
  sleep_duration: 30s

light:
  - platform: esp32_rmt_led_strip
    chipset: WS2812
    pin: GPIO48
    num_leds: 1
    rgb_order: GRB
    name: "OGRGB Light"
    id: ogrgb_light
    default_transition_length: 0s
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - mqtt.publish:
          topic: ogrgb/light/light_status
          payload: "on"
          qos: 1
          retain: true
      - lambda: 'ESP_LOGD("Light", "Light turned on"); id(last_light_on) = true;'
    on_turn_off:
      - mqtt.publish:
          topic: ogrgb/light/light_status
          payload: "off"
          qos: 1
          retain: true
      - lambda: 'ESP_LOGD("Light", "Light turned off"); id(last_light_on) = false;'
    effects:
      - addressable_rainbow:
          name: "Rainbow"
          speed: 10

script:
  - id: update_light
    mode: queued
    then:
      # A) If no Wi-Fi, bail out & schedule sleep
      - if:
          condition:
            wifi.connected
          then:
            - logger.log: "Wi-Fi is up → proceeding with light logic."
          else:
            - logger.log: "update_light: no Wi-Fi → scheduling sleep & retry"
            - deep_sleep.allow: deep_sleep_1

      # B) Run only if we stayed in the 'then' above
      - if:
          condition:
            wifi.connected
          then:
            # Case 1: online_lock is true → rainbow effect
            - if:
                condition:
                  lambda: 'return id(online_lock);'
                then:
                  - logger.log: "online_lock=true → showing rainbow effect"
                  - light.turn_on:
                      id: ogrgb_light
                      brightness: 40%
                      effect: "Rainbow"
                  - mqtt.publish:
                      topic: ogrgb/light/light_color
                      payload: "rainbow"
                      qos: 1
                      retain: true

            # Case 2: online_lock is false → normal behavior
            - if:
                condition:
                  lambda: 'return !id(online_lock);'
                then:
                  # 1) MQTT Seen Check
                  - if:
                      condition:
                        lambda: 'return !id(mqtt_seen_recently);'
                      then:
                        - logger.log: "No MQTT messages seen — assuming MQTT is offline"
                        - light.turn_on:
                            id: ogrgb_light
                            brightness: 40%
                            red: 100%
                            green: 100%
                            blue: 0%
                        - mqtt.publish:
                            topic: ogrgb/light/light_color
                            payload: "yellow"
                            qos: 1
                            retain: true
                        - delay: 500ms
                        - mqtt.publish:
                            topic: ogrgb/status
                            payload: "offline"
                            qos: 1
                            retain: true
                        - deep_sleep.allow: deep_sleep_1

                  # 2) Log current states
                  - lambda: |-
                      ESP_LOGI("update_light",
                               "door_open=%d, og_online=%d, online_lock=%d",
                               (int)id(door_open),
                               (int)id(og_online),
                               (int)id(online_lock));

                  # 3) Color logic
                  - if:
                      condition:
                        lambda: 'return id(door_open) && id(og_online);'
                      then:
                        - light.turn_on:
                            id: ogrgb_light
                            brightness: 40%
                            red: 0%
                            green: 100%
                            blue: 0%
                        - mqtt.publish:
                            topic: ogrgb/light/light_color
                            payload: "green"
                            qos: 1
                            retain: true
                      else:
                        - if:
                            condition:
                              lambda: 'return id(door_open) && !id(og_online);'
                            then:
                              - light.turn_on:
                                  id: ogrgb_light
                                  brightness: 40%
                                  red: 0%
                                  green: 0%
                                  blue: 100%
                              - mqtt.publish:
                                  topic: ogrgb/light/light_color
                                  payload: "blue"
                                  qos: 1
                                  retain: true
                            else:
                              - if:
                                  condition:
                                    lambda: 'return !id(door_open) && id(og_online);'
                                  then:
                                    - light.turn_off: ogrgb_light
                                    - mqtt.publish:
                                        topic: ogrgb/light/light_color
                                        payload: "none"
                                        qos: 1
                                        retain: true
                                  else:
                                    - light.turn_on:
                                        id: ogrgb_light
                                        brightness: 40%
                                        red: 100%
                                        green: 0%
                                        blue: 0%
                                    - mqtt.publish:
                                        topic: ogrgb/light/light_color
                                        payload: "red"
                                        qos: 1
                                        retain: true

                  # 4) Publish globals
                  - mqtt.publish:
                      topic: ogrgb/globals/door_open
                      payload: !lambda |-
                        return id(door_open) ? "true" : "false";
                      qos: 1
                      retain: true
                  - mqtt.publish:
                      topic: ogrgb/globals/og_online
                      payload: !lambda |-
                        return id(og_online) ? "true" : "false";
                      qos: 1
                      retain: true
                  - mqtt.publish:
                      topic: ogrgb/globals/online_lock
                      payload: !lambda |-
                        return id(online_lock) ? "true" : "false";
                      qos: 1
                      retain: true

                  # 5) Finally, if no lock, schedule sleep
                  - delay: 500ms
                  - mqtt.publish:
                      topic: ogrgb/status
                      payload: "offline"
                      qos: 1
                      retain: true
                  - deep_sleep.allow: deep_sleep_1

safe_mode:
  on_safe_mode:
    then:
      - logger.log: "Safe mode triggered!"
      - deep_sleep.prevent: deep_sleep_1


